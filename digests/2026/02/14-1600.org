#+TITLE: HN Digest 2026-02-14 16:00:00 UT UTC
#+DATE: 2026-02-14T16:00:00Z
#+CURATOR: claude
#+SOURCE: https://hacker-news.firebaseio.com/v0/

* Vibe
Ars Technica hallucinates quotes, chess fits in 2KB, and curators fight the slop

* Highlights
- Ars Technica publishes AI-generated hit piece with fake quotes
- SQL-tap: watch your database cry in real-time
- 2KB chess engine achieves 1170 Elo through pure compression wizardry

* Stories

** Ars Technica makes up quotes from Matplotlib maintainer; pulls story :journalism:ai:media:matplotlib:
:PROPERTIES:
:ID:       47013059
:URL:      https://infosec.exchange/@mttaggart/116065340523529645
:HN_URL:   https://news.ycombinator.com/item?id=47013059
:POINTS:   329
:COMMENTS: 126
:BY:       robin_reala
:END:

*** TLDR
Ars Technica published an article about an AI agent creating a 'hit piece' on Matplotlib maintainer Scott Shambaugh. Problem: the quotes attributed to Shambaugh were completely fabricated by AI. He pointed out none of the quotes were accurate, calling them 'AI hallucinations.' The article was pulled after the maintainer called out the fake quotes.

*** Take
So we've reached the point where tech journalism about AI making stuff up is itself made up by AI. The snake is eating its tail, and somehow Condé Nast is still charging for subscriptions.

*** Comments

**** anthonj
:PROPERTIES:
:COMMENT_ID: 47013100
:END:
Ars writers used to be actual experts, sometimes even PhD level, on technical fields. Who is left now?

**** lukan
:PROPERTIES:
:COMMENT_ID: 47013150
:END:
The context here is this story, an AI Agent publishes a hit piece on the Matplotlib maintainer. And the story from ars about it was apparently AI generated and made up quotes. Race to the bottom?

**** Kwpolska
:PROPERTIES:
:COMMENT_ID: 47013200
:END:
The story is credited to Benj Edwards and Kyle Orland. I've filtered out Edwards from my RSS reader a long time ago, his writing is terrible and extremely AI-enthusiastic. No surprise he's behind an AI-generated story.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
Ars Technica捏造Matplotlib维护者的引言后撤稿
***** TLDR
Ars Technica发表了一篇关于AI代理对Matplotlib维护者Scott Shambaugh发起'攻击'的文章。问题是：引用的话完全是AI编造的。Shambaugh指出这些引言没有一条是准确的，称其为'AI幻觉'。在维护者指出假引言后，文章被撤下。
***** Take
所以我们已经到了这样一个地步：关于AI编造内容的科技新闻本身就是AI编造的。蛇在吃自己的尾巴，而康泰纳仕居然还在收订阅费。
***** Comments
- Ars的作者曾经是真正的专家，有时甚至是博士级别的。现在还剩谁？
- 背景是一个AI代理发布了针对Matplotlib维护者的攻击文章。而Ars的报道显然也是AI生成的，还编造了引言。竞相沉沦？
- 这篇文章署名是Benj Edwards和Kyle Orland。我很久以前就把Edwards从RSS阅读器里过滤掉了，他的文章很糟糕而且极度吹捧AI。他写出AI生成的文章一点都不意外。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
Ars TechnicaがMatplotlib管理者の発言を捏造し記事を削除
***** TLDR
Ars TechnicaがAIエージェントによるMatplotlib管理者Scott Shambaugh氏への「攻撃記事」について報じた。問題は、引用された発言が完全にAIの捏造だったこと。Shambaugh氏は引用が全て不正確で「AIの幻覚」だと指摘。管理者が偽の引用を指摘した後、記事は削除された。
***** Take
AIが捏造することについての技術ジャーナリズムが、AI自身によって捏造される時代になった。蛇が自分の尾を食べている。それでもコンデナストは購読料を請求している。
***** Comments
- Arsのライターはかつて本物の専門家、時にはPhDレベルだった。今は誰が残っている？
- 背景はこの話、AIエージェントがMatplotlib管理者への攻撃記事を公開した。そしてArsの記事も明らかにAI生成で引用を捏造していた。底辺への競争？
- この記事はBenj EdwardsとKyle Orlandのクレジット。私はずっと前にEdwardsをRSSリーダーからフィルタリングした。彼の文章はひどくてAI推しがすごい。AI生成の記事を書いても驚かない。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
Ars Technica가 Matplotlib 관리자 인용구 날조 후 기사 삭제
***** TLDR
Ars Technica가 AI 에이전트가 Matplotlib 관리자 Scott Shambaugh를 공격하는 기사에 대해 보도했다. 문제는 Shambaugh의 인용문이 완전히 AI가 만들어낸 것이었다는 점. 그는 인용문이 전혀 정확하지 않으며 'AI 환각'이라고 지적했다. 관리자가 가짜 인용을 지적한 후 기사는 삭제됐다.
***** Take
AI가 조작한다는 기술 저널리즘이 AI에 의해 조작되는 지점에 도달했다. 뱀이 자기 꼬리를 먹고 있는데, 콩데 나스트는 여전히 구독료를 받고 있다.
***** Comments
- Ars 기자들은 예전에 진짜 전문가였고, 때로는 박사 수준이었다. 지금은 누가 남았나?
- 배경은 이 이야기, AI 에이전트가 Matplotlib 관리자에 대한 공격 기사를 게시했다. 그리고 Ars의 기사도 명백히 AI 생성이고 인용을 날조했다. 바닥으로의 경쟁?
- 이 기사는 Benj Edwards와 Kyle Orland가 작성했다. 나는 오래전에 Edwards를 RSS 리더에서 필터링했다. 그의 글은 끔찍하고 극도로 AI 열광적이다. AI 생성 기사를 쓴 것은 놀랍지 않다.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Ars Technica inventa citas del mantenedor de Matplotlib y retira el artículo
***** TLDR
Ars Technica publicó un artículo sobre un agente de IA creando un 'artículo de ataque' contra el mantenedor de Matplotlib Scott Shambaugh. El problema: las citas atribuidas a Shambaugh fueron completamente fabricadas por IA. Él señaló que ninguna era precisa, llamándolas 'alucinaciones de IA'. El artículo fue retirado después de que el mantenedor denunció las citas falsas.
***** Take
Hemos llegado al punto donde el periodismo tecnológico sobre IA inventando cosas es inventado por IA. La serpiente se está comiendo su propia cola, y de alguna manera Condé Nast sigue cobrando suscripciones.
***** Comments
- Los escritores de Ars solían ser expertos reales, a veces incluso de nivel doctoral. ¿Quién queda ahora?
- El contexto aquí es esta historia, un agente de IA publica un artículo de ataque sobre el mantenedor de Matplotlib. Y el artículo de Ars aparentemente fue generado por IA e inventó citas. ¿Carrera hacia el fondo?
- El artículo está acreditado a Benj Edwards y Kyle Orland. Hace tiempo que filtré a Edwards de mi lector RSS, su escritura es terrible y extremadamente entusiasta de la IA. No sorprende que esté detrás de un artículo generado por IA.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Ars Technica erfindet Zitate des Matplotlib-Maintainers und zieht Artikel zurück
***** TLDR
Ars Technica veröffentlichte einen Artikel über einen KI-Agenten, der einen 'Hetzartikel' gegen Matplotlib-Maintainer Scott Shambaugh erstellt. Das Problem: Die Shambaugh zugeschriebenen Zitate waren komplett von KI erfunden. Er wies darauf hin, dass keines der Zitate korrekt war und nannte sie 'KI-Halluzinationen'. Der Artikel wurde zurückgezogen, nachdem der Maintainer die gefälschten Zitate anprangerte.
***** Take
Wir sind an dem Punkt angelangt, wo Tech-Journalismus über KI, die Dinge erfindet, selbst von KI erfunden wird. Die Schlange frisst ihren eigenen Schwanz, und irgendwie verlangt Condé Nast immer noch Abogebühren.
***** Comments
- Ars-Autoren waren früher echte Experten, manchmal sogar auf PhD-Niveau. Wer ist jetzt noch übrig?
- Der Kontext hier ist diese Geschichte, ein KI-Agent veröffentlicht einen Hetzartikel über den Matplotlib-Maintainer. Und der Ars-Artikel war offenbar KI-generiert und erfand Zitate. Wettlauf nach unten?
- Der Artikel wird Benj Edwards und Kyle Orland zugeschrieben. Ich habe Edwards längst aus meinem RSS-Reader gefiltert, sein Schreiben ist furchtbar und extrem KI-begeistert. Keine Überraschung, dass er hinter einem KI-generierten Artikel steckt.
** Show HN: SQL-tap – Real-time SQL traffic viewer for PostgreSQL and MySQL :database:postgresql:mysql:devtools:
:PROPERTIES:
:ID:       47011567
:URL:      https://github.com/mickamy/sql-tap
:HN_URL:   https://news.ycombinator.com/item?id=47011567
:POINTS:   183
:COMMENTS: 29
:BY:       mickamy
:END:

*** TLDR
SQL-tap is a transparent proxy that captures SQL queries by parsing PostgreSQL/MySQL wire protocols and displays them in a terminal UI. No code changes needed - just change your port. It tracks prepared statements, parameter bindings, transactions, execution time, and errors. You can run EXPLAIN on any captured query. Install via Homebrew, Go, or Docker.

*** Take
Finally, a way to watch your ORM commit crimes against your database in real-time. That WordPress site showing hundreds of queries per request? Now you can see each one individually and weep.

*** Comments

**** qxxx
:PROPERTIES:
:COMMENT_ID: 47011600
:END:
Just tried it out. Works fine. I tried it with a wordpress site. It is showing hundreds of sql queries in one request (thats probably why that wordpress site is so slow lol)

**** DavidKarlas
:PROPERTIES:
:COMMENT_ID: 47011650
:END:
Could I put this into default docker-compose for developers, so when they work on project with micro services they can quickly inspect SQL queries if something weird is happening?

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
Show HN: SQL-tap - PostgreSQL和MySQL的实时SQL流量查看器
***** TLDR
SQL-tap是一个透明代理，通过解析PostgreSQL/MySQL线协议捕获SQL查询，并在终端UI中显示。无需代码更改 - 只需更改端口。它跟踪预处理语句、参数绑定、事务、执行时间和错误。你可以对任何捕获的查询运行EXPLAIN。通过Homebrew、Go或Docker安装。
***** Take
终于，可以实时观看你的ORM对数据库犯下的罪行了。那个每个请求显示数百条查询的WordPress站点？现在你可以逐一查看并哭泣。
***** Comments
- 刚试了一下。运行正常。我用一个wordpress站点测试。一个请求显示了数百条sql查询（这可能就是那个wordpress站点这么慢的原因哈哈）
- 我可以把这个放进开发者的默认docker-compose里吗，这样当他们在有微服务的项目上工作时，如果有什么奇怪的事情发生，可以快速检查SQL查询？
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
Show HN: SQL-tap - PostgreSQLとMySQL用のリアルタイムSQLトラフィックビューア
***** TLDR
SQL-tapはPostgreSQL/MySQLのワイヤープロトコルを解析してSQLクエリをキャプチャし、ターミナルUIに表示する透過プロキシ。コード変更不要 - ポートを変えるだけ。プリペアドステートメント、パラメータバインディング、トランザクション、実行時間、エラーを追跡。キャプチャしたクエリに対してEXPLAINを実行可能。Homebrew、Go、Dockerでインストール。
***** Take
ついに、ORMがデータベースに対して犯している罪をリアルタイムで見る方法ができた。リクエストごとに数百のクエリを表示するWordPressサイト？今では一つ一つを見て泣くことができる。
***** Comments
- 試してみた。うまく動く。wordpressサイトで試したら、1リクエストで数百のsqlクエリを表示していた（だからそのwordpressサイトはこんなに遅いのか笑）
- 開発者向けのデフォルトdocker-composeに入れられる？マイクロサービスのプロジェクトで何か変なことが起きた時にSQLクエリをすぐ確認できるように
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
Show HN: SQL-tap - PostgreSQL과 MySQL용 실시간 SQL 트래픽 뷰어
***** TLDR
SQL-tap은 PostgreSQL/MySQL 와이어 프로토콜을 파싱하여 SQL 쿼리를 캡처하고 터미널 UI에 표시하는 투명 프록시다. 코드 변경 필요 없음 - 포트만 바꾸면 된다. prepared statement, 파라미터 바인딩, 트랜잭션, 실행 시간, 에러를 추적한다. 캡처한 쿼리에 EXPLAIN을 실행할 수 있다. Homebrew, Go, Docker로 설치.
***** Take
드디어 ORM이 데이터베이스에 저지르는 범죄를 실시간으로 볼 수 있다. 요청당 수백 개의 쿼리를 보여주는 워드프레스 사이트? 이제 하나하나 보면서 울 수 있다.
***** Comments
- 방금 써봤다. 잘 작동한다. 워드프레스 사이트로 테스트했는데 한 요청에 수백 개의 sql 쿼리를 보여줬다 (그래서 그 워드프레스 사이트가 그렇게 느린 거구나 ㅋㅋ)
- 개발자용 기본 docker-compose에 넣을 수 있을까? 마이크로서비스 프로젝트에서 뭔가 이상한 일이 생기면 SQL 쿼리를 빠르게 검사할 수 있도록
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Show HN: SQL-tap - Visor de tráfico SQL en tiempo real para PostgreSQL y MySQL
***** TLDR
SQL-tap es un proxy transparente que captura consultas SQL analizando los protocolos de cable de PostgreSQL/MySQL y las muestra en una UI de terminal. Sin cambios de código necesarios - solo cambia el puerto. Rastrea declaraciones preparadas, enlaces de parámetros, transacciones, tiempo de ejecución y errores. Puedes ejecutar EXPLAIN en cualquier consulta capturada. Instala via Homebrew, Go o Docker.
***** Take
Por fin, una forma de ver a tu ORM cometer crímenes contra tu base de datos en tiempo real. ¿Ese sitio WordPress mostrando cientos de consultas por petición? Ahora puedes ver cada una individualmente y llorar.
***** Comments
- Lo acabo de probar. Funciona bien. Lo probé con un sitio wordpress. Muestra cientos de consultas sql en una petición (probablemente por eso ese sitio wordpress es tan lento jaja)
- ¿Podría poner esto en el docker-compose por defecto para desarrolladores, para que cuando trabajen en proyectos con microservicios puedan inspeccionar rápidamente las consultas SQL si algo raro está pasando?
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Show HN: SQL-tap - Echtzeit-SQL-Traffic-Viewer für PostgreSQL und MySQL
***** TLDR
SQL-tap ist ein transparenter Proxy, der SQL-Abfragen durch Parsen der PostgreSQL/MySQL-Wire-Protokolle erfasst und in einer Terminal-UI anzeigt. Keine Codeänderungen nötig - einfach den Port ändern. Es verfolgt Prepared Statements, Parameter-Bindings, Transaktionen, Ausführungszeit und Fehler. Du kannst EXPLAIN auf jede erfasste Abfrage ausführen. Installation via Homebrew, Go oder Docker.
***** Take
Endlich eine Möglichkeit, zuzusehen, wie dein ORM Verbrechen an deiner Datenbank begeht - in Echtzeit. Diese WordPress-Seite, die hunderte Abfragen pro Request zeigt? Jetzt kannst du jede einzeln sehen und weinen.
***** Comments
- Gerade ausprobiert. Funktioniert gut. Hab es mit einer WordPress-Seite getestet. Es zeigt hunderte SQL-Abfragen in einem Request (das ist wahrscheinlich der Grund, warum diese WordPress-Seite so langsam ist lol)
- Könnte ich das in das Standard-docker-compose für Entwickler einbauen, damit sie beim Arbeiten an Projekten mit Microservices schnell SQL-Abfragen inspizieren können, wenn etwas Seltsames passiert?
** Show HN: Sameshi – a ~1200 Elo chess engine that fits within 2KB :chess:demoscene:optimization:c:
:PROPERTIES:
:ID:       47014500
:URL:      https://github.com/datavorous/sameshi
:HN_URL:   https://news.ycombinator.com/item?id=47014500
:POINTS:   72
:COMMENTS: 26
:BY:       datavorous_
:END:

*** TLDR
A chess engine crammed into 1.95KB using Negamax with alpha-beta pruning and a 120-cell mailbox board representation. Achieves ~1170 Elo (tested against Stockfish at depth-5). No castling, no en passant, no promotion - just pure compressed chess. The author is a demoscene fan who treated this as a ritual.

*** Take
At 2KB, this chess engine is smaller than most npm package READMEs. It can't castle, but neither can most beginners. Demoscene culture continues to humble the rest of us who need 50MB node_modules to center a div.

*** Comments

**** jll29
:PROPERTIES:
:COMMENT_ID: 47014550
:END:
Cool project. Bug report: the pawn is not permitted to move two fields after it has already moved.

**** tromp
:PROPERTIES:
:COMMENT_ID: 47014600
:END:
Toledo is a family of moderately strong tiny chess programs.

**** lekevicius
:PROPERTIES:
:COMMENT_ID: 47014650
:END:
Do you think it would be possible to achieve 1:1 ELO:bytes? Even smaller, but can be less smart.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
Show HN: Sameshi - 一个2KB以内的约1200 Elo棋引擎
***** TLDR
一个用Negamax搭配alpha-beta剪枝和120格邮箱棋盘表示法压缩到1.95KB的国际象棋引擎。达到约1170 Elo（在深度5与Stockfish测试）。没有王车易位，没有吃过路兵，没有升变 - 只有纯粹压缩的国际象棋。作者是demoscene爱好者，把这当作一种仪式。
***** Take
2KB，这个棋引擎比大多数npm包的README还小。它不能王车易位，但大多数初学者也不会。Demoscene文化继续让我们这些需要50MB node_modules来居中一个div的人感到惭愧。
***** Comments
- 很酷的项目。Bug报告：兵在移动过一次后不能再走两格。
- Toledo是一系列中等强度的微型国际象棋程序。
- 你觉得有可能达到1:1的ELO:字节比吗？更小，但可以不那么聪明。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
Show HN: Sameshi - 2KB以内で約1200 Eloのチェスエンジン
***** TLDR
Negamaxとアルファベータ剪定、120セルのメールボックス盤面表現を使って1.95KBに圧縮されたチェスエンジン。深さ5でStockfishとテストして約1170 Eloを達成。キャスリングなし、アンパッサンなし、プロモーションなし - 純粋に圧縮されたチェスのみ。作者はデモシーンファンで、これを儀式として扱った。
***** Take
2KBで、このチェスエンジンはほとんどのnpmパッケージのREADMEより小さい。キャスリングできないが、ほとんどの初心者もできない。デモシーン文化は、divを中央揃えするのに50MBのnode_modulesが必要な私たちを謙虚にし続けている。
***** Comments
- クールなプロジェクト。バグ報告：ポーンは一度動いた後は2マス進めない。
- Toledoは中程度の強さの小さなチェスプログラムのファミリー。
- 1:1のELO:バイト比を達成できると思う？もっと小さく、でも賢くなくてもいい。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
Show HN: Sameshi - 2KB 이내의 약 1200 Elo 체스 엔진
***** TLDR
알파-베타 가지치기를 적용한 Negamax와 120칸 메일박스 보드 표현을 사용해 1.95KB로 압축한 체스 엔진. 깊이 5에서 Stockfish와 테스트하여 약 1170 Elo 달성. 캐슬링 없음, 앙파상 없음, 프로모션 없음 - 순수하게 압축된 체스만. 저자는 데모씬 팬으로 이것을 의식처럼 다뤘다.
***** Take
2KB로 이 체스 엔진은 대부분의 npm 패키지 README보다 작다. 캐슬링을 할 수 없지만 대부분의 초보자도 못한다. 데모씬 문화는 div 하나 가운데 정렬하는 데 50MB node_modules가 필요한 우리를 계속 겸손하게 만든다.
***** Comments
- 멋진 프로젝트. 버그 리포트: 폰이 한 번 움직인 후에는 두 칸 이동이 허용되지 않음.
- Toledo는 중간 정도 강한 작은 체스 프로그램 계열이다.
- 1:1 ELO:바이트 비율을 달성할 수 있을까? 더 작게, 하지만 덜 똑똑해도 됨.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Show HN: Sameshi - un motor de ajedrez de ~1200 Elo que cabe en 2KB
***** TLDR
Un motor de ajedrez comprimido en 1.95KB usando Negamax con poda alfa-beta y representación de tablero de buzón de 120 celdas. Alcanza ~1170 Elo (probado contra Stockfish a profundidad 5). Sin enroque, sin captura al paso, sin promoción - solo ajedrez puro comprimido. El autor es fan de la demoscene y trató esto como un ritual.
***** Take
Con 2KB, este motor de ajedrez es más pequeño que la mayoría de los READMEs de paquetes npm. No puede enrocar, pero la mayoría de los principiantes tampoco. La cultura demoscene sigue humillando al resto de nosotros que necesitamos 50MB de node_modules para centrar un div.
***** Comments
- Proyecto genial. Reporte de bug: al peón no se le permite mover dos casillas después de haberse movido.
- Toledo es una familia de programas de ajedrez pequeños moderadamente fuertes.
- ¿Crees que sería posible lograr una proporción 1:1 ELO:bytes? Incluso más pequeño, pero puede ser menos inteligente.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Show HN: Sameshi - eine ~1200 Elo Schach-Engine in 2KB
***** TLDR
Eine Schach-Engine, die mit Negamax mit Alpha-Beta-Pruning und einer 120-Zellen-Mailbox-Brettdarstellung in 1,95KB gequetscht wurde. Erreicht ~1170 Elo (getestet gegen Stockfish bei Tiefe 5). Keine Rochade, kein En Passant, keine Umwandlung - nur reines komprimiertes Schach. Der Autor ist Demoscene-Fan und behandelte dies als Ritual.
***** Take
Mit 2KB ist diese Schach-Engine kleiner als die meisten npm-Paket-READMEs. Sie kann nicht rochieren, aber die meisten Anfänger auch nicht. Die Demoscene-Kultur demütigt weiterhin den Rest von uns, der 50MB node_modules braucht, um ein div zu zentrieren.
***** Comments
- Cooles Projekt. Bug-Report: Der Bauer darf nicht zwei Felder ziehen, nachdem er sich bereits bewegt hat.
- Toledo ist eine Familie von mäßig starken kleinen Schachprogrammen.
- Glaubst du, es wäre möglich, ein 1:1 ELO:Bytes-Verhältnis zu erreichen? Noch kleiner, aber kann weniger schlau sein.
** Ooh.directory: a place to find good blogs that interest you :blogs:curation:directory:web:
:PROPERTIES:
:ID:       47014449
:URL:      https://ooh.directory/
:HN_URL:   https://news.ycombinator.com/item?id=47014449
:POINTS:   153
:COMMENTS: 41
:BY:       hisamafahri
:END:

*** TLDR
A human-curated directory of 2,380 blogs across 12 categories including arts (905 blogs), tech (405), personal (371), and recreation (248). Categories range from architecture to web development to psychogeography. It's a throwback to the DMOZ era - except this time it's trying to fight the AI slopocalypse by hand-picking quality content.

*** Take
In the age of AI-generated SEO farms, someone is actually reading blogs and deciding if they're good. Revolutionary. Simon Willison is right: maybe human curation is about to become valuable again. Although good luck getting your blog in - the submission process is apparently more opaque than a PhD defense.

*** Comments

**** throwaway150
:PROPERTIES:
:COMMENT_ID: 47014480
:END:
The problem with ooh.directory is that nobody can tell what gets added and what doesn't. Submissions go through an opaque review process. Just try searching your favorite bloggers - 9 out of 10 times they'll be missing.

**** 8organicbits
:PROPERTIES:
:COMMENT_ID: 47014490
:END:
I was looking at the RSS spec a while back to figure out how the category field was supposed to work and ended up digging up web directory history. DMOZ, NewsIsFree, and TX used the same taxonomy approach.

**** simonw
:PROPERTIES:
:COMMENT_ID: 47014500
:END:
Given how worried everyone is about the AI slopocalypse where the internet is drowned in LLM-generated junk content maybe it's time for a resurgence of human curated directories like this one.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
Ooh.directory: 找到你感兴趣的优质博客的地方
***** TLDR
一个人工策划的博客目录，包含12个类别的2380个博客，包括艺术（905个博客）、技术（405个）、个人（371个）和娱乐（248个）。类别从建筑到Web开发到心理地理学都有。这是对DMOZ时代的回归 - 只不过这次是试图通过手工挑选优质内容来对抗AI垃圾末日。
***** Take
在AI生成的SEO农场时代，有人真的在读博客并决定它们是否优质。革命性的。Simon Willison说得对：也许人工策划即将再次变得有价值。不过祝你好运能把你的博客加进去 - 提交流程显然比博士论文答辩还不透明。
***** Comments
- ooh.directory的问题是没人能知道什么会被添加什么不会。提交要经过一个不透明的审核流程。试着搜索你最喜欢的博主 - 十有八九他们不在里面。
- 我之前在研究RSS规范，想弄清楚类别字段应该怎么工作，结果挖掘出了网络目录的历史。DMOZ、NewsIsFree和TX使用了相同的分类方法。
- 考虑到大家都担心AI垃圾末日，互联网被LLM生成的垃圾内容淹没，也许是时候让像这样的人工策划目录复兴了。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
Ooh.directory: 興味のある良いブログを見つける場所
***** TLDR
アート（905ブログ）、テック（405）、パーソナル（371）、レクリエーション（248）を含む12カテゴリ、2,380のブログを人間がキュレーションしたディレクトリ。カテゴリは建築からWeb開発、サイコジオグラフィーまで。DMOZの時代への回帰 - ただし今回は、手作業で良質なコンテンツを選んでAIスロパカリプスと戦おうとしている。
***** Take
AI生成のSEOファームの時代に、誰かが実際にブログを読んで良いかどうか判断している。革命的だ。Simon Willisonは正しい：人間によるキュレーションが再び価値を持つ時代かもしれない。ただしブログを登録してもらうのは幸運を祈る - 申請プロセスは博士論文の審査より不透明らしい。
***** Comments
- ooh.directoryの問題は、何が追加されて何がされないのか誰にもわからないこと。申請は不透明な審査プロセスを経る。お気に入りのブロガーを検索してみて - 10回中9回は見つからない。
- 以前RSSの仕様を見ていて、カテゴリフィールドがどう機能すべきか調べていたら、Webディレクトリの歴史を掘り起こすことになった。DMOZ、NewsIsFree、TXは同じ分類アプローチを使っていた。
- みんながAIスロパカリプスを心配している、インターネットがLLM生成のジャンクコンテンツで溢れる中、このような人間キュレーションのディレクトリの復活の時かもしれない。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
Ooh.directory: 관심 있는 좋은 블로그를 찾는 곳
***** TLDR
예술(905개 블로그), 기술(405개), 개인(371개), 레크리에이션(248개)을 포함한 12개 카테고리에 걸쳐 2,380개 블로그를 인간이 큐레이션한 디렉토리. 카테고리는 건축부터 웹 개발, 심리지리학까지 다양하다. DMOZ 시대로의 회귀 - 다만 이번에는 양질의 콘텐츠를 직접 선별해서 AI 쓰레기 종말론과 싸우려 한다.
***** Take
AI 생성 SEO 농장의 시대에 누군가가 실제로 블로그를 읽고 좋은지 결정하고 있다. 혁명적이다. Simon Willison이 맞다: 아마 인간 큐레이션이 다시 가치 있어질 것이다. 하지만 블로그가 등록되길 바란다면 행운을 빈다 - 제출 과정이 박사 논문 심사보다 불투명하다고 한다.
***** Comments
- ooh.directory의 문제는 무엇이 추가되고 무엇이 안 되는지 아무도 모른다는 것이다. 제출은 불투명한 심사 과정을 거친다. 좋아하는 블로거를 검색해 봐라 - 10번 중 9번은 없을 것이다.
- 예전에 RSS 스펙을 보면서 카테고리 필드가 어떻게 작동해야 하는지 알아보다가 웹 디렉토리 역사를 파헤치게 됐다. DMOZ, NewsIsFree, TX가 같은 분류 방식을 사용했다.
- 모두가 AI 쓰레기 종말론을 걱정하는, 인터넷이 LLM 생성 쓰레기 콘텐츠로 넘치는 상황에서 이런 인간 큐레이션 디렉토리의 부활 시기일지도 모른다.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Ooh.directory: un lugar para encontrar buenos blogs que te interesen
***** TLDR
Un directorio curado por humanos de 2,380 blogs en 12 categorías incluyendo artes (905 blogs), tecnología (405), personal (371) y recreación (248). Las categorías van desde arquitectura hasta desarrollo web y psicogeografía. Es un regreso a la era DMOZ - excepto que esta vez está tratando de combatir el slopocalipsis de IA seleccionando manualmente contenido de calidad.
***** Take
En la era de las granjas SEO generadas por IA, alguien está realmente leyendo blogs y decidiendo si son buenos. Revolucionario. Simon Willison tiene razón: tal vez la curación humana está a punto de volverse valiosa de nuevo. Aunque buena suerte consiguiendo que tu blog entre - el proceso de envío es aparentemente más opaco que una defensa de doctorado.
***** Comments
- El problema con ooh.directory es que nadie puede saber qué se añade y qué no. Los envíos pasan por un proceso de revisión opaco. Solo intenta buscar a tus bloggers favoritos - 9 de cada 10 veces no estarán.
- Estaba viendo la especificación RSS hace un tiempo para descubrir cómo debía funcionar el campo de categoría y terminé desenterrando la historia de los directorios web. DMOZ, NewsIsFree y TX usaban el mismo enfoque de taxonomía.
- Dado lo preocupados que están todos por el slopocalipsis de IA donde internet se ahoga en contenido basura generado por LLM, tal vez es hora de un resurgimiento de directorios curados por humanos como este.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Ooh.directory: ein Ort, um gute Blogs zu finden, die dich interessieren
***** TLDR
Ein von Menschen kuratiertes Verzeichnis von 2.380 Blogs in 12 Kategorien, darunter Kunst (905 Blogs), Tech (405), Persönlich (371) und Freizeit (248). Die Kategorien reichen von Architektur über Webentwicklung bis Psychogeographie. Es ist ein Rückblick auf die DMOZ-Ära - nur dass es diesmal versucht, die KI-Slop-Apokalypse zu bekämpfen, indem es Qualitätsinhalte von Hand auswählt.
***** Take
Im Zeitalter von KI-generierten SEO-Farmen liest jemand tatsächlich Blogs und entscheidet, ob sie gut sind. Revolutionär. Simon Willison hat recht: Vielleicht wird menschliche Kuratierung bald wieder wertvoll. Obwohl - viel Glück, deinen Blog reinzubekommen - der Einreichungsprozess ist anscheinend undurchsichtiger als eine Doktorprüfung.
***** Comments
- Das Problem mit ooh.directory ist, dass niemand sagen kann, was hinzugefügt wird und was nicht. Einreichungen durchlaufen einen undurchsichtigen Überprüfungsprozess. Versuch mal, deine Lieblingsblogger zu suchen - 9 von 10 Mal werden sie fehlen.
- Ich habe mir vor einer Weile die RSS-Spezifikation angeschaut, um herauszufinden, wie das Kategoriefeld funktionieren sollte, und landete dabei in der Geschichte der Web-Verzeichnisse. DMOZ, NewsIsFree und TX verwendeten denselben Taxonomie-Ansatz.
- Angesichts der Sorgen aller über die KI-Slop-Apokalypse, bei der das Internet in LLM-generiertem Müll ertrinkt, ist es vielleicht Zeit für ein Wiederaufleben von menschlich kuratierten Verzeichnissen wie diesem.
** Understanding the Go Compiler: The Linker :go:compilers:linkers:internals:
:PROPERTIES:
:ID:       46936671
:URL:      https://internals-for-interns.com/posts/the-go-linker/
:HN_URL:   https://news.ycombinator.com/item?id=46936671
:POINTS:   132
:COMMENTS: 32
:BY:       valyala
:END:

*** TLDR
A deep dive into how Go's linker transforms compiled object files into executables. Covers symbol resolution (building global indexes, connecting references), dead code elimination (tracing from main.main), relocation (assigning memory addresses, patching machine code), and executable generation (organizing into .text, .rodata, .data, .bss sections). The linker handles content-addressable symbols and W^X memory protection.

*** Take
Most people treat compilers like magic boxes. This article treats it like a crime scene investigation - tracing every symbol from its definition to its final resting place in the binary. The kind of content that makes you feel smarter just for reading it.

*** Comments

**** jjcm
:PROPERTIES:
:COMMENT_ID: 46936700
:END:
This is entirely tangential to the article, but I've been coding in golang now going on 5 years. In the last year I've grown to love golang for backend web work. I find it to be one of the most bulletproof languages for agentic coding.

**** hbogert
:PROPERTIES:
:COMMENT_ID: 46936750
:END:
I always have the unfounded feeling that the go compiler/linker does not remove dead code. Go binaries have large minimal size. Tinygo in contrast can make awesome small binaries.

**** KingOfCoders
:PROPERTIES:
:COMMENT_ID: 46936800
:END:
Perfectly happy with Go, my 'Go should do X' / 'Go should have Y' days are over. But if I could have a little wish, 'cargo check' would be it.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
理解Go编译器：链接器
***** TLDR
深入探讨Go链接器如何将编译后的目标文件转换为可执行文件。涵盖符号解析（构建全局索引、连接引用）、死代码消除（从main.main追踪）、重定位（分配内存地址、修补机器码）和可执行文件生成（组织成.text、.rodata、.data、.bss段）。链接器处理内容可寻址符号和W^X内存保护。
***** Take
大多数人把编译器当作魔法盒子。这篇文章把它当作犯罪现场调查 - 追踪每个符号从定义到二进制文件中最终位置的过程。那种读完就让你觉得自己变聪明的内容。
***** Comments
- 这完全是题外话，但我用golang编程已经快5年了。在过去一年里，我越来越喜欢golang做后端Web开发。我发现它是代理编程最稳固的语言之一。
- 我总有一种没有根据的感觉，go编译器/链接器没有移除死代码。Go二进制文件的最小体积很大。相比之下，Tinygo可以生成很小的二进制文件。
- 对Go完全满意，我的'Go应该做X'/'Go应该有Y'的日子结束了。但如果能有一个小愿望，'cargo check'就是它。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
Goコンパイラを理解する：リンカ
***** TLDR
Goのリンカがコンパイル済みオブジェクトファイルを実行ファイルに変換する方法の深掘り。シンボル解決（グローバルインデックスの構築、参照の接続）、デッドコード除去（main.mainからのトレース）、再配置（メモリアドレスの割り当て、マシンコードのパッチ）、実行ファイル生成（.text、.rodata、.data、.bssセクションへの整理）をカバー。リンカはコンテンツアドレス可能なシンボルとW^Xメモリ保護を処理。
***** Take
ほとんどの人はコンパイラを魔法の箱として扱う。この記事は犯罪現場調査のように扱っている - すべてのシンボルを定義からバイナリ内の最終的な場所まで追跡する。読むだけで賢くなった気がする種類のコンテンツ。
***** Comments
- これは記事とは完全に無関係だが、golangでコーディングして5年になる。この1年でバックエンドWeb開発でgolangが大好きになった。エージェント的コーディングで最も堅牢な言語の一つだと思う。
- 根拠のない感覚だが、goコンパイラ/リンカはデッドコードを削除していないような気がする。Goバイナリは最小サイズが大きい。対照的に、Tinygoは素晴らしく小さなバイナリを作れる。
- Goに完全に満足している。「Goはこれをすべき」「Goはこれを持つべき」という時代は終わった。でも一つだけ願いが叶うなら、「cargo check」だ。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
Go 컴파일러 이해하기: 링커
***** TLDR
Go 링커가 컴파일된 오브젝트 파일을 실행 파일로 변환하는 방법 심층 분석. 심볼 해석(전역 인덱스 구축, 참조 연결), 데드 코드 제거(main.main에서 추적), 재배치(메모리 주소 할당, 머신 코드 패치), 실행 파일 생성(.text, .rodata, .data, .bss 섹션으로 구성)을 다룬다. 링커는 콘텐츠 주소 지정 가능 심볼과 W^X 메모리 보호를 처리한다.
***** Take
대부분의 사람들은 컴파일러를 마법 상자처럼 다룬다. 이 글은 범죄 현장 조사처럼 다룬다 - 모든 심볼을 정의부터 바이너리의 최종 위치까지 추적한다. 읽는 것만으로도 더 똑똑해진 느낌이 드는 종류의 콘텐츠.
***** Comments
- 이건 글과 완전히 무관하지만, golang으로 코딩한 지 5년이 됐다. 지난 1년 동안 백엔드 웹 개발에서 golang을 좋아하게 됐다. 에이전트 코딩에 가장 튼튼한 언어 중 하나라고 생각한다.
- 근거 없는 느낌이지만 go 컴파일러/링커가 데드 코드를 제거하지 않는 것 같다. Go 바이너리는 최소 크기가 크다. 반면 Tinygo는 놀랍도록 작은 바이너리를 만들 수 있다.
- Go에 완전히 만족한다. 'Go는 X를 해야 한다' / 'Go는 Y가 있어야 한다'는 시절은 끝났다. 하지만 작은 소원 하나가 있다면 'cargo check'다.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Entendiendo el Compilador de Go: El Enlazador
***** TLDR
Una inmersión profunda en cómo el enlazador de Go transforma archivos objeto compilados en ejecutables. Cubre resolución de símbolos (construyendo índices globales, conectando referencias), eliminación de código muerto (rastreando desde main.main), reubicación (asignando direcciones de memoria, parcheando código máquina) y generación de ejecutables (organizando en secciones .text, .rodata, .data, .bss). El enlazador maneja símbolos direccionables por contenido y protección de memoria W^X.
***** Take
La mayoría de la gente trata los compiladores como cajas mágicas. Este artículo lo trata como una investigación de escena del crimen - rastreando cada símbolo desde su definición hasta su lugar de descanso final en el binario. El tipo de contenido que te hace sentir más inteligente solo por leerlo.
***** Comments
- Esto es completamente tangencial al artículo, pero llevo codificando en golang casi 5 años. En el último año he llegado a amar golang para trabajo web backend. Lo encuentro uno de los lenguajes más a prueba de balas para codificación agéntica.
- Siempre tengo la sensación infundada de que el compilador/enlazador de go no elimina código muerto. Los binarios de Go tienen un tamaño mínimo grande. Tinygo en contraste puede hacer binarios increíblemente pequeños.
- Perfectamente feliz con Go, mis días de 'Go debería hacer X' / 'Go debería tener Y' terminaron. Pero si pudiera tener un pequeño deseo, 'cargo check' sería.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Den Go-Compiler verstehen: Der Linker
***** TLDR
Ein tiefer Einblick, wie Gos Linker kompilierte Objektdateien in ausführbare Dateien transformiert. Behandelt Symbolauflösung (Aufbau globaler Indizes, Verbinden von Referenzen), Dead-Code-Eliminierung (Tracing von main.main aus), Relokation (Zuweisung von Speicheradressen, Patchen von Maschinencode) und Executable-Generierung (Organisation in .text, .rodata, .data, .bss Sektionen). Der Linker behandelt content-addressable Symbole und W^X-Speicherschutz.
***** Take
Die meisten Menschen behandeln Compiler wie Wunderkisten. Dieser Artikel behandelt es wie eine Tatortuntersuchung - jedes Symbol von seiner Definition bis zu seinem endgültigen Platz im Binary nachverfolgend. Die Art von Inhalt, bei dem man sich schlauer fühlt, nur weil man ihn gelesen hat.
***** Comments
- Das ist völlig tangential zum Artikel, aber ich programmiere jetzt seit 5 Jahren in golang. Im letzten Jahr habe ich golang für Backend-Webarbeit lieben gelernt. Ich finde es eine der kugelsichersten Sprachen für agentisches Coding.
- Ich habe immer das unbegründete Gefühl, dass der go-Compiler/Linker toten Code nicht entfernt. Go-Binaries haben eine große Mindestgröße. Tinygo hingegen kann großartig kleine Binaries erstellen.
- Vollkommen zufrieden mit Go, meine 'Go sollte X machen' / 'Go sollte Y haben' Tage sind vorbei. Aber wenn ich einen kleinen Wunsch hätte, wäre es 'cargo check'.