#+TITLE: HN Digest 2026-01-09 01:00:00 UT UTC
#+DATE: 2026-01-09T01:00:00Z
#+CURATOR: claude
#+SOURCE: https://hacker-news.firebaseio.com/v0/

* Vibe
Claude Code gets naked, Fourier transforms everything, and HN argues about robot voices

* Highlights
- Claude Code: 200 lines of Python, infinite hype
- Sopro TTS: Voice cloning on your potato CPU
- Unix v4: Buffer overflows since 1973

* Stories

** How to Code Claude Code in 200 Lines of Code :ai:programming:agents:
:PROPERTIES:
:ID:       46545620
:URL:      https://www.mihaileric.com/The-Emperor-Has-No-Clothes/
:HN_URL:   https://news.ycombinator.com/item?id=46545620
:POINTS:   290
:COMMENTS: 140
:BY:       nutellalover
:END:

*** TLDR
Author demonstrates that AI coding assistants are just a simple loop: LLM decides what to do, your code executes it. Three tools (read files, list files, edit files) plus a conversation loop equals Claude Code. The LLM never touches your filesystem, it just asks politely.

*** Take
The emperor's new clothes are actually a very nice bathrobe. Yes, it's simple at the core, but that's like saying a car is just 'wheels plus engine.' The devil's in the TODO list injection and early-stopping prevention that the comments correctly point out.

*** Comments

**** lmeyerov
:PROPERTIES:
:COMMENT_ID: 46545621
:END:
A big 'aha' for effective use of these tools is realizing they run on dynamic TODO lists. Plan mode is basically bootstrapping how that TODO list gets seeded.

**** libraryofbabel
:PROPERTIES:
:COMMENT_ID: 46545622
:END:
The core of a coding agent is really simple, it's a loop with tool calling. But you should at least reference Thorsten Ball's excellent article from way back.

**** nyellin
:PROPERTIES:
:COMMENT_ID: 46545623
:END:
The agent in the post will demonstrate 'early stopping' where it finishes before the task is really done. You'd think reasoning models would fix this, but SOTA models still fail.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
如何用200行代码编写Claude Code
***** TLDR
作者展示了AI编程助手只是一个简单循环：LLM决定做什么，你的代码执行它。三个工具（读文件、列文件、编辑文件）加上对话循环就等于Claude Code。LLM从不接触你的文件系统，它只是礼貌地请求。
***** Take
皇帝的新衣实际上是件不错的浴袍。是的，核心很简单，但这就像说汽车只是'轮子加引擎'。魔鬼在于评论正确指出的TODO列表注入和防止提前停止。
***** Comments
- 有效使用这些工具的一大顿悟是意识到它们运行在动态TODO列表上。计划模式基本上是在启动TODO列表的种子。
- 编程代理的核心真的很简单，就是带工具调用的循环。但你至少应该引用Thorsten Ball很久以前的优秀文章。
- 文章中的代理会表现出'提前停止'，即在任务真正完成之前就结束。你以为推理模型能解决这个问题，但SOTA模型仍然失败。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
Claude Codeを200行のコードで作る方法
***** TLDR
著者はAIコーディングアシスタントが単純なループであることを示す：LLMが何をするか決め、コードが実行する。3つのツール（ファイル読み取り、一覧、編集）と会話ループでClaude Codeになる。LLMはファイルシステムに触れない、丁寧にお願いするだけ。
***** Take
裸の王様の新しい服は実はいいバスローブだった。確かにコアはシンプルだが、車は「車輪とエンジン」と言うようなもの。コメントが正しく指摘するTODOリスト注入と早期停止防止に悪魔が潜む。
***** Comments
- これらのツールを効果的に使う大きな気づきは、動的TODOリストで動いていると理解すること。プランモードは基本的にTODOリストの種まき。
- コーディングエージェントのコアは本当にシンプル、ツール呼び出しのループだ。でもThorsten Ballの昔の素晴らしい記事は参照すべき。
- 記事のエージェントはタスクが本当に終わる前に終了する「早期停止」を示す。推論モデルで直ると思うが、SOTAモデルでも失敗する。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
200줄의 코드로 Claude Code 만들기
***** TLDR
저자는 AI 코딩 어시스턴트가 단순한 루프임을 보여준다: LLM이 무엇을 할지 결정하고, 코드가 실행한다. 세 가지 도구(파일 읽기, 목록, 편집)와 대화 루프로 Claude Code가 된다. LLM은 파일 시스템을 건드리지 않고 공손하게 요청할 뿐이다.
***** Take
벌거벗은 임금님의 새 옷은 사실 괜찮은 목욕 가운이었다. 핵심은 단순하지만, 자동차가 '바퀴와 엔진'일 뿐이라고 말하는 것과 같다. 댓글이 정확히 지적한 TODO 목록 주입과 조기 중단 방지에 악마가 숨어 있다.
***** Comments
- 이 도구들을 효과적으로 사용하는 큰 깨달음은 동적 TODO 목록에서 실행된다는 것을 이해하는 것이다. 계획 모드는 기본적으로 TODO 목록 시딩을 부트스트랩한다.
- 코딩 에이전트의 핵심은 정말 간단하다, 도구 호출이 있는 루프다. 하지만 Thorsten Ball의 훌륭한 예전 글은 참조해야 한다.
- 글의 에이전트는 작업이 실제로 완료되기 전에 끝나는 '조기 중단'을 보여준다. 추론 모델이 이걸 고칠 거라 생각하지만 SOTA 모델도 실패한다.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Cómo programar Claude Code en 200 líneas de código
***** TLDR
El autor demuestra que los asistentes de codificación AI son solo un bucle simple: el LLM decide qué hacer, tu código lo ejecuta. Tres herramientas (leer archivos, listar archivos, editar archivos) más un bucle de conversación equivale a Claude Code. El LLM nunca toca tu sistema de archivos, solo pide amablemente.
***** Take
La ropa nueva del emperador es en realidad una bata bastante bonita. Sí, el núcleo es simple, pero eso es como decir que un coche es solo 'ruedas más motor'. El diablo está en la inyección de listas TODO y la prevención de parada temprana que los comentarios señalan correctamente.
***** Comments
- Un gran momento 'ajá' para usar efectivamente estas herramientas es darse cuenta de que funcionan con listas TODO dinámicas. El modo de planificación básicamente inicializa cómo se siembra esa lista TODO.
- El núcleo de un agente de codificación es realmente simple, es un bucle con llamadas a herramientas. Pero al menos deberías hacer referencia al excelente artículo de Thorsten Ball de hace tiempo.
- El agente del post demostrará 'parada temprana' donde termina antes de que la tarea esté realmente hecha. Pensarías que los modelos de razonamiento lo arreglarían, pero los modelos SOTA aún fallan.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Wie man Claude Code in 200 Zeilen Code programmiert
***** TLDR
Der Autor zeigt, dass KI-Coding-Assistenten nur eine einfache Schleife sind: LLM entscheidet was zu tun ist, dein Code führt es aus. Drei Werkzeuge (Dateien lesen, auflisten, bearbeiten) plus Konversationsschleife ergibt Claude Code. Das LLM berührt dein Dateisystem nie, es fragt nur höflich.
***** Take
Des Kaisers neue Kleider sind eigentlich ein ganz netter Bademantel. Ja, der Kern ist einfach, aber das ist wie zu sagen, ein Auto sei nur 'Räder plus Motor'. Der Teufel steckt in der TODO-Listen-Injektion und der Verhinderung vorzeitigen Stoppens, die die Kommentare richtig ansprechen.
***** Comments
- Ein großes 'Aha' für die effektive Nutzung dieser Tools ist zu erkennen, dass sie auf dynamischen TODO-Listen laufen. Der Planungsmodus bootstrappt im Grunde, wie diese TODO-Liste gesetzt wird.
- Der Kern eines Coding-Agenten ist wirklich einfach, es ist eine Schleife mit Tool-Aufrufen. Aber du solltest zumindest auf Thorsten Balls exzellenten Artikel von damals verweisen.
- Der Agent im Post zeigt 'frühes Stoppen', wo er aufhört bevor die Aufgabe wirklich erledigt ist. Man würde denken, Reasoning-Modelle beheben das, aber SOTA-Modelle versagen immer noch.
** Sopro TTS: A 169M model with zero-shot voice cloning that runs on the CPU :ai:audio:tts:opensource:
:PROPERTIES:
:ID:       46546113
:URL:      https://github.com/samuel-vitorino/sopro
:HN_URL:   https://news.ycombinator.com/item?id=46546113
:POINTS:   119
:COMMENTS: 55
:BY:       sammyyyyyyy
:END:

*** TLDR
A 169M parameter TTS model that does zero-shot voice cloning and runs on CPU at 0.25x real-time factor. Built with dilated convolutions instead of transformers, trained on a single L40S GPU. Feed it 3-12 seconds of reference audio and it'll mimic the voice. Quality varies wildly.

*** Take
Finally, a voice cloning model that respects your 2015 MacBook Air. The HN comments are split between 'sounds amazing' and 'sounds like a corrupted WAV file from 1998' which is peak machine learning discourse.

*** Comments

**** guerrilla
:PROPERTIES:
:COMMENT_ID: 46546114
:END:
I played the audio and it sounds absolutely horrible, far worse than computer voices sounded fifteen years ago. Am I not hearing the same thing everyone else is hearing?

**** realityfactchex
:PROPERTIES:
:COMMENT_ID: 46546115
:END:
That's cool and useful. IMO, the best alternative is Chatterbox-TTS-Server (slower, but quite high quality).

**** derefr
:PROPERTIES:
:COMMENT_ID: 46546116
:END:
Is there yet any model that works as a voice modulator, taking a continuous audio stream and transforming speech to have the tone and timbre of another voice?

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
Sopro TTS：可在CPU上运行的1.69亿参数零样本语音克隆模型
***** TLDR
一个1.69亿参数的TTS模型，可以进行零样本语音克隆，在CPU上以0.25倍实时速度运行。使用扩张卷积而非transformer构建，在单个L40S GPU上训练。给它3-12秒的参考音频，它就会模仿那个声音。质量参差不齐。
***** Take
终于有一个尊重你2015年MacBook Air的语音克隆模型了。HN评论分成'听起来很棒'和'听起来像1998年损坏的WAV文件'两派，这就是机器学习讨论的巅峰。
***** Comments
- 我播放了音频，听起来绝对糟糕，比十五年前的电脑声音还差。我听到的和别人听到的不一样吗？
- 这很酷很有用。在我看来，最好的替代品是Chatterbox-TTS-Server（更慢，但质量相当高）。
- 有没有可以作为变声器的模型，接受连续的音频流，将语音转换成另一个声音的音色？
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
Sopro TTS：CPUで動作する1.69億パラメータのゼロショット音声クローニングモデル
***** TLDR
1.69億パラメータのTTSモデルで、ゼロショット音声クローニングが可能、CPUで0.25倍リアルタイムで動作。Transformerの代わりに拡張畳み込みで構築、単一のL40S GPUで訓練。3-12秒の参照音声を与えると声を模倣する。品質はバラバラ。
***** Take
ついに2015年のMacBook Airを尊重する音声クローニングモデルが登場。HNコメントは「素晴らしい」と「1998年の破損WAVファイルみたい」に分かれており、これが機器学習議論の頂点。
***** Comments
- 音声を再生したが、ひどい音だ。15年前のコンピューター音声より悪い。私だけ違うものを聞いているのか？
- クールで便利だ。私見では、最良の代替はChatterbox-TTS-Server（遅いが高品質）。
- 連続音声ストリームを受け取り、別の声の音色に変換するボイスモジュレーターとして機能するモデルはあるのか？
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
Sopro TTS: CPU에서 실행되는 1.69억 파라미터 제로샷 음성 복제 모델
***** TLDR
1.69억 파라미터 TTS 모델로 제로샷 음성 복제가 가능하며 CPU에서 0.25배 실시간으로 실행된다. 트랜스포머 대신 확장 컨볼루션으로 구축, 단일 L40S GPU에서 훈련. 3-12초 참조 오디오를 주면 목소리를 모방한다. 품질은 들쭉날쭉.
***** Take
드디어 2015년 MacBook Air를 존중하는 음성 복제 모델이 나왔다. HN 댓글은 '놀랍다'와 '1998년 손상된 WAV 파일 같다'로 나뉘는데, 이게 바로 머신러닝 담론의 정점이다.
***** Comments
- 오디오를 재생했는데 정말 끔찍하다, 15년 전 컴퓨터 음성보다 훨씬 나쁘다. 나만 다른 걸 듣고 있는 건가?
- 쿨하고 유용하다. 내 생각에 최고의 대안은 Chatterbox-TTS-Server다 (더 느리지만 꽤 고품질).
- 연속 오디오 스트림을 받아서 다른 목소리의 톤과 음색으로 변환하는 보이스 모듈레이터 모델이 있나?
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Sopro TTS: Un modelo de 169M con clonación de voz zero-shot que funciona en CPU
***** TLDR
Un modelo TTS de 169M parámetros que hace clonación de voz zero-shot y funciona en CPU a 0.25x tiempo real. Construido con convoluciones dilatadas en lugar de transformers, entrenado en una sola GPU L40S. Dale 3-12 segundos de audio de referencia y imitará la voz. La calidad varía mucho.
***** Take
Por fin, un modelo de clonación de voz que respeta tu MacBook Air de 2015. Los comentarios de HN están divididos entre 'suena increíble' y 'suena como un archivo WAV corrupto de 1998', lo cual es el pico del discurso de machine learning.
***** Comments
- Reproduje el audio y suena absolutamente horrible, mucho peor que las voces de computadora de hace quince años. ¿No estoy escuchando lo mismo que todos los demás?
- Eso está genial y es útil. En mi opinión, la mejor alternativa es Chatterbox-TTS-Server (más lento, pero de bastante alta calidad).
- ¿Existe algún modelo que funcione como modulador de voz, tomando un flujo de audio continuo y transformando el habla para tener el tono y timbre de otra voz?
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Sopro TTS: Ein 169M Modell mit Zero-Shot Voice Cloning, das auf der CPU läuft
***** TLDR
Ein 169M Parameter TTS-Modell, das Zero-Shot Voice Cloning macht und auf der CPU mit 0,25x Echtzeit läuft. Mit dilatierten Faltungen statt Transformern gebaut, auf einer einzelnen L40S GPU trainiert. Gib ihm 3-12 Sekunden Referenzaudio und es ahmt die Stimme nach. Qualität variiert stark.
***** Take
Endlich ein Voice-Cloning-Modell, das dein 2015er MacBook Air respektiert. Die HN-Kommentare sind gespalten zwischen 'klingt fantastisch' und 'klingt wie eine korrupte WAV-Datei von 1998', was der Höhepunkt des Machine-Learning-Diskurses ist.
***** Comments
- Ich habe das Audio abgespielt und es klingt absolut schrecklich, viel schlimmer als Computerstimmen vor fünfzehn Jahren. Höre ich nicht dasselbe wie alle anderen?
- Das ist cool und nützlich. Meiner Meinung nach ist die beste Alternative Chatterbox-TTS-Server (langsamer, aber ziemlich hohe Qualität).
- Gibt es schon ein Modell, das als Stimmenmodulator funktioniert, einen kontinuierlichen Audiostream nimmt und Sprache in den Ton und die Klangfarbe einer anderen Stimme umwandelt?
** The Unreasonable Effectiveness of the Fourier Transform :math:signal-processing:engineering:
:PROPERTIES:
:ID:       46544981
:URL:      https://joshuawise.com/resources/ofdm/
:HN_URL:   https://news.ycombinator.com/item?id=46544981
:POINTS:   126
:COMMENTS: 54
:BY:       voxadam
:END:

*** TLDR
A deep dive into why the Fourier Transform keeps showing up everywhere in engineering, from OFDM in wireless communications to signal processing. Includes a Jupyter notebook with visualizations and references to a 1966 OFDM patent. Title riffs on Wigner's famous essay about math's unreasonable effectiveness.

*** Take
Every few months HN rediscovers that Fourier transforms are magic and the comments turn into a support group for signal processing enthusiasts. Someone always mentions dishwashers. It's beautiful.

*** Comments

**** derektank
:PROPERTIES:
:COMMENT_ID: 46544982
:END:
Gauss stumbled upon the FFT algorithm over a century before Cooley and Tukey's 1965 publication. He was studying asteroid motion and wrote it in his notes but it never made it into publication.

**** Jun8
:PROPERTIES:
:COMMENT_ID: 46544983
:END:
A signal cannot be both time and frequency band limited. This fact I learned in undergrad is equivalent to the Uncertainty Principle! Also, my wife and I argue about dishwasher loading - we're optimizing for frequency and time domains.

**** hedgehog
:PROPERTIES:
:COMMENT_ID: 46544984
:END:
I have demo code that uses Fourier transform on webcam video to read a heartrate off a person's face, basically looking for what frequency holds peak energy.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
傅里叶变换的不合理有效性
***** TLDR
深入探讨傅里叶变换为何在工程领域无处不在，从无线通信中的OFDM到信号处理。包含带可视化的Jupyter笔记本和1966年OFDM专利的引用。标题致敬维格纳关于数学不合理有效性的著名论文。
***** Take
每隔几个月HN就会重新发现傅里叶变换是魔法，评论区变成信号处理爱好者的互助小组。总有人会提到洗碗机。真美。
***** Comments
- 高斯在库利和图基1965年发表论文前一个多世纪就发现了FFT算法。他当时在研究小行星运动，写在笔记里但从未发表。
- 信号不能同时在时间和频率上都是带限的。我本科学到的这个事实等价于不确定性原理！另外，我和妻子争论洗碗机的装法——我们在优化频域和时域。
- 我有演示代码，用傅里叶变换处理网络摄像头视频，从人脸读取心率，基本上是寻找哪个频率有峰值能量。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
フーリエ変換の不合理な有効性
***** TLDR
フーリエ変換がなぜ無線通信のOFDMから信号処理まで、工学のあらゆる場所に現れるかを深掘り。可視化付きJupyterノートブックと1966年のOFDM特許への参照を含む。タイトルはウィグナーの数学の不合理な有効性についての有名なエッセイをもじっている。
***** Take
数ヶ月ごとにHNはフーリエ変換が魔法であることを再発見し、コメント欄は信号処理愛好家のサポートグループになる。必ず誰かが食洗機に言及する。美しい。
***** Comments
- ガウスはクーリーとチューキーの1965年の論文より1世紀以上前にFFTアルゴリズムを発見していた。小惑星の運動を研究中にノートに書いたが、出版されることはなかった。
- 信号は時間と周波数の両方で帯域制限にすることはできない。学部で学んだこの事実は不確定性原理と等価だ！また、妻と食洗機の積み方で議論する——周波数領域と時間領域で最適化している。
- ウェブカメラ映像にフーリエ変換を使って人の顔から心拍数を読み取るデモコードがある。基本的にどの周波数がピークエネルギーを持つかを探している。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
푸리에 변환의 불합리한 효과성
***** TLDR
푸리에 변환이 무선 통신의 OFDM에서 신호 처리까지 공학 전반에 왜 계속 등장하는지 심층 분석. 시각화가 포함된 Jupyter 노트북과 1966년 OFDM 특허 참조 포함. 제목은 수학의 불합리한 효과성에 대한 위그너의 유명한 에세이를 패러디.
***** Take
몇 달마다 HN은 푸리에 변환이 마법이라는 것을 재발견하고 댓글은 신호 처리 매니아들의 자조 모임으로 변한다. 항상 누군가가 식기세척기를 언급한다. 아름답다.
***** Comments
- 가우스는 쿨리와 투키의 1965년 논문보다 1세기 이상 전에 FFT 알고리즘을 발견했다. 소행성 운동을 연구하면서 노트에 적었지만 출판되지 않았다.
- 신호는 시간과 주파수 모두에서 대역 제한될 수 없다. 학부에서 배운 이 사실이 불확정성 원리와 동등하다! 또한 아내와 식기세척기 적재 방법으로 논쟁한다 — 주파수 영역과 시간 영역을 최적화하고 있다.
- 웹캠 비디오에 푸리에 변환을 사용해 사람 얼굴에서 심박수를 읽는 데모 코드가 있다. 기본적으로 어떤 주파수가 피크 에너지를 갖는지 찾는 것이다.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
La Efectividad Irrazonable de la Transformada de Fourier
***** TLDR
Una inmersión profunda en por qué la Transformada de Fourier aparece en todas partes de la ingeniería, desde OFDM en comunicaciones inalámbricas hasta procesamiento de señales. Incluye un cuaderno Jupyter con visualizaciones y referencias a una patente OFDM de 1966. El título hace referencia al famoso ensayo de Wigner sobre la efectividad irrazonable de las matemáticas.
***** Take
Cada pocos meses HN redescubre que las transformadas de Fourier son magia y los comentarios se convierten en un grupo de apoyo para entusiastas del procesamiento de señales. Siempre alguien menciona lavavajillas. Es hermoso.
***** Comments
- Gauss descubrió el algoritmo FFT más de un siglo antes de la publicación de Cooley y Tukey de 1965. Estaba estudiando el movimiento de asteroides y lo escribió en sus notas pero nunca se publicó.
- Una señal no puede estar limitada en banda tanto en tiempo como en frecuencia. ¡Este hecho que aprendí en la universidad es equivalente al Principio de Incertidumbre! Además, mi esposa y yo discutimos sobre cómo cargar el lavavajillas — estamos optimizando para dominios de frecuencia y tiempo.
- Tengo código de demostración que usa la transformada de Fourier en video de webcam para leer el ritmo cardíaco de la cara de una persona, básicamente buscando qué frecuencia tiene la energía máxima.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Die unvernünftige Wirksamkeit der Fourier-Transformation
***** TLDR
Ein tiefer Einblick, warum die Fourier-Transformation überall in der Technik auftaucht, von OFDM in der drahtlosen Kommunikation bis zur Signalverarbeitung. Enthält ein Jupyter-Notebook mit Visualisierungen und Verweise auf ein OFDM-Patent von 1966. Der Titel spielt auf Wigners berühmten Essay über die unvernünftige Wirksamkeit der Mathematik an.
***** Take
Alle paar Monate entdeckt HN wieder, dass Fourier-Transformationen Magie sind und die Kommentare werden zu einer Selbsthilfegruppe für Signalverarbeitungs-Enthusiasten. Jemand erwähnt immer Geschirrspüler. Es ist wunderschön.
***** Comments
- Gauß stolperte über den FFT-Algorithmus über ein Jahrhundert vor Cooley und Tukeys Veröffentlichung 1965. Er studierte Asteroidenbewegungen und schrieb es in seine Notizen, aber es wurde nie veröffentlicht.
- Ein Signal kann nicht gleichzeitig zeit- und frequenzbandlimitiert sein. Diese Tatsache, die ich im Grundstudium gelernt habe, ist äquivalent zum Unschärfeprinzip! Außerdem streiten meine Frau und ich über das Beladen des Geschirrspülers — wir optimieren für Frequenz- und Zeitdomäne.
- Ich habe Demo-Code, der die Fourier-Transformation auf Webcam-Video anwendet, um die Herzfrequenz aus dem Gesicht einer Person zu lesen, im Wesentlichen nach der Frequenz mit der Spitzenenergie suchend.
** Fixing a Buffer Overflow in Unix v4 Like It's 1973 :security:unix:history:c:
:PROPERTIES:
:ID:       46544610
:URL:      https://sigma-star.at/blog/2025/12/unix-v4-buffer-overflow/
:HN_URL:   https://news.ycombinator.com/item?id=46544610
:POINTS:   77
:COMMENTS: 19
:BY:       vzaliva
:END:

*** TLDR
The Unix v4 'su' command had a classic buffer overflow: 100-byte password buffer with no bounds checking. Author patches it 1973-style using the ed line editor, compiles, and deploys. The fix adds a counter and size check. Back then, systems were isolated so security was simpler (read: nonexistent).

*** Take
Buffer overflows: causing security researchers job security since before most of us were born. The comments section immediately tries to exploit it, because of course they do.

*** Comments

**** w-m
:PROPERTIES:
:COMMENT_ID: 46544611
:END:
Will you overwrite pwbuf when writing past password? Could you type the same password that's exactly 100 bytes twice and hit enter to gain root? Edit: no, silly, password is overwritten with its hash before the comparison.

**** nineteen999
:PROPERTIES:
:COMMENT_ID: 46544612
:END:
Already patched this on my x86_64 v4 UNIX port. Hehe.

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
像1973年那样修复Unix v4中的缓冲区溢出
***** TLDR
Unix v4的'su'命令有一个经典的缓冲区溢出：100字节的密码缓冲区没有边界检查。作者使用ed行编辑器以1973年的方式修补，编译并部署。修复添加了计数器和大小检查。那时系统是隔离的，所以安全更简单（也就是：不存在）。
***** Take
缓冲区溢出：在我们大多数人出生之前就为安全研究人员提供工作保障。评论区立即尝试利用它，因为当然会这样。
***** Comments
- 写入超过password时会覆盖pwbuf吗？你能输入正好100字节的相同密码两次然后按回车获得root权限吗？编辑：不行，傻瓜，密码在比较前会被哈希覆盖。
- 已经在我的x86_64 v4 UNIX移植版上打了这个补丁。嘿嘿。
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
1973年のようにUnix v4のバッファオーバーフローを修正する
***** TLDR
Unix v4の'su'コマンドには典型的なバッファオーバーフローがあった：100バイトのパスワードバッファに境界チェックがない。著者はedラインエディタで1973年スタイルでパッチを当て、コンパイルしてデプロイ。修正はカウンタとサイズチェックを追加。当時システムは隔離されていたのでセキュリティはシンプルだった（つまり：存在しなかった）。
***** Take
バッファオーバーフロー：私たちのほとんどが生まれる前からセキュリティ研究者に仕事を保証している。コメント欄はすぐにこれを悪用しようとする、当然だ。
***** Comments
- passwordを超えて書き込むとpwbufを上書きするのか？ちょうど100バイトの同じパスワードを2回入力してEnterを押すとrootになれる？編集：いや、馬鹿だな、パスワードは比較前にハッシュで上書きされる。
- 私のx86_64 v4 UNIXポートではすでにパッチ済み。へへ。
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
1973년처럼 Unix v4의 버퍼 오버플로우 수정하기
***** TLDR
Unix v4의 'su' 명령에는 전형적인 버퍼 오버플로우가 있었다: 100바이트 비밀번호 버퍼에 경계 검사가 없음. 저자는 ed 라인 편집기로 1973년 스타일로 패치하고, 컴파일하고, 배포한다. 수정은 카운터와 크기 검사를 추가한다. 당시 시스템은 격리되어 있어서 보안은 더 단순했다(즉: 존재하지 않았다).
***** Take
버퍼 오버플로우: 우리 대부분이 태어나기 전부터 보안 연구자들에게 일자리를 보장해왔다. 댓글 섹션은 즉시 이것을 악용하려 한다, 당연하지.
***** Comments
- password를 넘어서 쓰면 pwbuf를 덮어쓰게 되나? 정확히 100바이트인 같은 비밀번호를 두 번 입력하고 엔터를 치면 root를 얻을 수 있나? 편집: 아니, 바보야, 비밀번호는 비교 전에 해시로 덮어써진다.
- 내 x86_64 v4 UNIX 포트에서는 이미 패치했다. 헤헤.
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Arreglando un Desbordamiento de Búfer en Unix v4 Como en 1973
***** TLDR
El comando 'su' de Unix v4 tenía un clásico desbordamiento de búfer: búfer de contraseña de 100 bytes sin verificación de límites. El autor lo parchea al estilo 1973 usando el editor de líneas ed, compila y despliega. La corrección añade un contador y verificación de tamaño. En aquel entonces, los sistemas estaban aislados así que la seguridad era más simple (léase: inexistente).
***** Take
Desbordamientos de búfer: dando seguridad laboral a investigadores de seguridad desde antes de que la mayoría de nosotros naciéramos. La sección de comentarios inmediatamente intenta explotarlo, porque por supuesto que sí.
***** Comments
- ¿Sobrescribirás pwbuf al escribir más allá de password? ¿Podrías escribir la misma contraseña de exactamente 100 bytes dos veces y presionar enter para obtener root? Edición: no, tonto, password se sobrescribe con su hash antes de la comparación.
- Ya parcheé esto en mi port de UNIX v4 para x86_64. Jeje.
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Einen Pufferüberlauf in Unix v4 reparieren wie 1973
***** TLDR
Der Unix v4 'su'-Befehl hatte einen klassischen Pufferüberlauf: 100-Byte-Passwortpuffer ohne Grenzprüfung. Autor patcht es im Stil von 1973 mit dem ed-Zeileneditor, kompiliert und deployt. Der Fix fügt einen Zähler und Größenprüfung hinzu. Damals waren Systeme isoliert, also war Sicherheit einfacher (sprich: nicht existent).
***** Take
Pufferüberläufe: geben Sicherheitsforschern Jobsicherheit seit bevor die meisten von uns geboren wurden. Der Kommentarbereich versucht sofort, es auszunutzen, weil natürlich.
***** Comments
- Überschreibst du pwbuf, wenn du über password hinausschreibst? Könntest du das gleiche Passwort mit genau 100 Bytes zweimal eingeben und Enter drücken, um root zu werden? Edit: nein, dumm, password wird vor dem Vergleich mit seinem Hash überschrieben.
- Habe das bereits auf meinem x86_64 v4 UNIX-Port gepatcht. Hehe.
** Show HN: macOS menu bar app to track Claude usage in real time :macos:tools:claude:showhn:
:PROPERTIES:
:ID:       46544524
:URL:      https://github.com/richhickson/claudecodeusage
:HN_URL:   https://news.ycombinator.com/item?id=46544524
:POINTS:   73
:COMMENTS: 30
:BY:       RichHickson
:END:

*** TLDR
A native Swift menu bar app that shows your Claude Code usage limits in real-time. Reads OAuth creds from macOS Keychain, hits an undocumented Anthropic API, displays color-coded status (green/yellow/red), and shows time until reset. No analytics, credentials stay local. Requires Claude Code CLI.

*** Take
We've reached the point where we need dedicated apps to tell us when we've talked to the AI too much today. The future is hitting rate limits on your robot therapist.

*** Comments

**** dewey
:PROPERTIES:
:COMMENT_ID: 46544525
:END:
Alternatively there's also CodexBar with 1.7k stars already, supporting more services despite the name.

**** rootlocus
:PROPERTIES:
:COMMENT_ID: 46544526
:END:
'Follow me on X' Why... just why? Why do people keep insisting on using it?

*** i18n                                                  :i18n:

**** zh
:PROPERTIES:
:LANG: zh
:END:
***** Title
Show HN：实时追踪Claude使用量的macOS菜单栏应用
***** TLDR
一个原生Swift菜单栏应用，实时显示你的Claude Code使用限制。从macOS钥匙串读取OAuth凭证，访问未公开的Anthropic API，显示颜色编码状态（绿/黄/红），并显示重置倒计时。无分析，凭证保留本地。需要Claude Code CLI。
***** Take
我们已经到了需要专门的应用来告诉我们今天和AI说得太多的地步。未来就是在你的机器人治疗师那里触发速率限制。
***** Comments
- 另外还有CodexBar，已经有1.7k星，尽管名字如此但支持更多服务。
- '在X上关注我' 为什么...就为什么？为什么人们还坚持使用它？
**** ja
:PROPERTIES:
:LANG: ja
:END:
***** Title
Show HN：Claude使用量をリアルタイムで追跡するmacOSメニューバーアプリ
***** TLDR
Claude Codeの使用制限をリアルタイムで表示するネイティブSwiftメニューバーアプリ。macOSキーチェーンからOAuth認証情報を読み取り、未公開のAnthropic APIにアクセス、色分けステータス（緑/黄/赤）を表示、リセットまでの時間を表示。分析なし、認証情報はローカルに保持。Claude Code CLIが必要。
***** Take
今日AIと話しすぎたかどうかを教えてくれる専用アプリが必要な時代になった。未来はロボットセラピストでレート制限に引っかかること。
***** Comments
- 代わりにCodexBarもあり、すでに1.7k スターがあり、名前に反してより多くのサービスをサポートしている。
- 「Xでフォローして」なぜ...なぜ？なぜ人々は使い続けるのか？
**** ko
:PROPERTIES:
:LANG: ko
:END:
***** Title
Show HN: Claude 사용량을 실시간으로 추적하는 macOS 메뉴 바 앱
***** TLDR
Claude Code 사용 제한을 실시간으로 보여주는 네이티브 Swift 메뉴 바 앱. macOS 키체인에서 OAuth 자격 증명을 읽고, 비공개 Anthropic API에 접근, 색상 코드 상태(녹색/노랑/빨강) 표시, 리셋까지 시간 표시. 분석 없음, 자격 증명은 로컬에 유지. Claude Code CLI 필요.
***** Take
오늘 AI와 너무 많이 대화했는지 알려주는 전용 앱이 필요한 시대에 도달했다. 미래는 로봇 치료사에게 속도 제한에 걸리는 것이다.
***** Comments
- 대안으로 CodexBar도 있는데, 이미 1.7k 스타를 받았고 이름과 달리 더 많은 서비스를 지원한다.
- 'X에서 팔로우하세요' 왜... 도대체 왜? 왜 사람들이 계속 사용하려고 하는 거지?
**** es
:PROPERTIES:
:LANG: es
:END:
***** Title
Show HN: App de barra de menú macOS para rastrear uso de Claude en tiempo real
***** TLDR
Una app nativa Swift de barra de menú que muestra tus límites de uso de Claude Code en tiempo real. Lee credenciales OAuth del Keychain de macOS, accede a una API no documentada de Anthropic, muestra estado codificado por colores (verde/amarillo/rojo), y muestra tiempo hasta el reinicio. Sin analytics, credenciales locales. Requiere Claude Code CLI.
***** Take
Hemos llegado al punto donde necesitamos apps dedicadas para decirnos cuando hemos hablado demasiado con la IA hoy. El futuro es alcanzar límites de tasa con tu terapeuta robot.
***** Comments
- Alternativamente también está CodexBar con 1.7k estrellas ya, soportando más servicios a pesar del nombre.
- 'Sígueme en X' Por qué... ¿solo por qué? ¿Por qué la gente sigue insistiendo en usarlo?
**** de
:PROPERTIES:
:LANG: de
:END:
***** Title
Show HN: macOS-Menüleisten-App zur Echtzeit-Verfolgung der Claude-Nutzung
***** TLDR
Eine native Swift-Menüleisten-App, die deine Claude Code Nutzungslimits in Echtzeit anzeigt. Liest OAuth-Anmeldedaten aus dem macOS-Schlüsselbund, greift auf eine undokumentierte Anthropic-API zu, zeigt farbcodierte Status (grün/gelb/rot) und Zeit bis zum Reset. Keine Analytics, Anmeldedaten bleiben lokal. Erfordert Claude Code CLI.
***** Take
Wir haben den Punkt erreicht, an dem wir dedizierte Apps brauchen, die uns sagen, wann wir heute zu viel mit der KI geredet haben. Die Zukunft ist, Rate-Limits bei deinem Roboter-Therapeuten zu erreichen.
***** Comments
- Alternativ gibt es auch CodexBar mit bereits 1,7k Sternen, unterstützt trotz des Namens mehr Dienste.
- 'Folge mir auf X' Warum... einfach nur warum? Warum bestehen die Leute weiter darauf, es zu benutzen?